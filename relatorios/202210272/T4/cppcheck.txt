planilhas.cpp:0:0: information: Too many #ifdef configurations - cppcheck only checks 12 of 106 configurations. Use --force to check all configurations. [toomanyconfigs]

^
catch.hpp:9316:21: style: Unused private function: 'ExeName::makeRef' [unusedPrivateFunction]
        static auto makeRef(LambdaT const &lambda) -> std::shared_ptr<BoundValueRefBase> {
                    ^
catch.hpp:615:9: style: Class 'StringRef' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        StringRef( char const* rawChars ) noexcept;
        ^
catch.hpp:622:9: style: Class 'StringRef' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        StringRef( std::string const& stdString ) noexcept
        ^
catch.hpp:960:5: style: Class 'TestInvokerAsMethod' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}
    ^
catch.hpp:2529:9: style: Class 'LazyExpression' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        LazyExpression( bool isNegated );
        ^
catch.hpp:2908:9: style: Class 'Section' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Section( SectionInfo const& info );
        ^
catch.hpp:3047:9: style: Class 'ExceptionTranslatorRegistrar' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {
        ^
catch.hpp:3021:13: style: Class 'ExceptionTranslator' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            ExceptionTranslator( std::string(*translateFunction)( T& ) )
            ^
catch.hpp:3398:5: style: Class 'ExceptionMessageMatcher' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    ExceptionMessageMatcher(std::string const& message):
    ^
catch.hpp:3552:13: style: Struct 'EqualsMatcher' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            EqualsMatcher( CasedString const& comparator );
            ^
catch.hpp:3556:13: style: Struct 'ContainsMatcher' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            ContainsMatcher( CasedString const& comparator );
            ^
catch.hpp:3560:13: style: Struct 'StartsWithMatcher' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            StartsWithMatcher( CasedString const& comparator );
            ^
catch.hpp:3564:13: style: Struct 'EndsWithMatcher' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            EndsWithMatcher( CasedString const& comparator );
            ^
catch.hpp:3604:13: style: Struct 'ContainsElementMatcher' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}
            ^
catch.hpp:3625:13: style: Struct 'ContainsMatcher' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            ContainsMatcher(std::vector<T, AllocComp> const &comparator) : m_comparator( comparator ) {}
            ^
catch.hpp:3655:13: style: Struct 'EqualsMatcher' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            EqualsMatcher(std::vector<T, AllocComp> const &comparator) : m_comparator( comparator ) {}
            ^
catch.hpp:3678:13: style: Struct 'ApproxMatcher' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            ApproxMatcher(std::vector<T, AllocComp> const& comparator) : m_comparator( comparator ) {}
            ^
catch.hpp:3713:13: style: Struct 'UnorderedEqualsMatcher' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            UnorderedEqualsMatcher(std::vector<T, AllocComp> const& target) : m_target(target) {}
            ^
catch.hpp:3918:5: style: Class 'GeneratorException' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    GeneratorException(const char* msg):
    ^
catch.hpp:3951:9: style: Class 'SingleValueGenerator' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        SingleValueGenerator(T&& value) : m_value(std::move(value)) {}
        ^
catch.hpp:3969:9: style: Class 'FixedValuesGenerator' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        FixedValuesGenerator( std::initializer_list<T> values ) : m_values( values ) {}
        ^
catch.hpp:3984:9: style: Class 'GeneratorWrapper' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        GeneratorWrapper(std::unique_ptr<IGenerator<T>> generator):
        ^
catch.hpp:4027:9: style: Class 'Generators' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Generators(Gs &&... moreGenerators) {
        ^
catch.hpp:5207:9: style: Class 'TestSpecParser' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TestSpecParser( ITagAliasRegistry const& tagAliases );
        ^
catch.hpp:5311:9: style: Class 'Config' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Config( ConfigData const& data );
        ^
catch.hpp:5502:9: style: Struct 'TestRunInfo' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TestRunInfo( std::string const& _name );
        ^
catch.hpp:5572:9: style: Struct 'TestGroupStats' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TestGroupStats( GroupInfo const& _groupInfo );
        ^
catch.hpp:5963:9: style: Struct 'TestEventListenerBase' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TestEventListenerBase( ReporterConfig const& _config );
        ^
catch.hpp:6016:9: style: Struct 'Colour' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Colour( Code _colourCode );
        ^
catch.hpp:6146:9: style: Struct 'ConsoleReporter' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        ConsoleReporter(ReporterConfig const& config);
        ^
catch.hpp:6226:9: style: Class 'XmlEncode' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes );
        ^
catch.hpp:6317:9: style: Class 'JunitReporter' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        JunitReporter(ReporterConfig const& _config);
        ^
catch.hpp:6365:9: style: Class 'XmlReporter' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        XmlReporter(ReporterConfig const& _config);
        ^
catch.hpp:8847:9: style: Class 'Args' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Args( std::initializer_list<std::string> args )
        ^
catch.hpp:9489:9: style: Struct 'Help' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Help( bool &showHelpFlag )
        ^
catch.hpp:12252:9: style: Class 'TestInvokerAsFunction' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        TestInvokerAsFunction( void(*testAsFunction)() ) noexcept;
        ^
catch.hpp:13627:13: style: Class 'FileStream' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            FileStream( StringRef filename ) {
            ^
catch.hpp:5827:13: style: Struct 'BySectionInfo' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            BySectionInfo( SectionInfo const& other ) : m_other( other ) {}
            ^
catch.hpp:5726:9: style: Struct 'StreamingReporterBase < TestEventListenerBase >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        StreamingReporterBase( ReporterConfig const& _config )
        ^
catch.hpp:5726:9: style: Struct 'StreamingReporterBase < CompactReporter >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        StreamingReporterBase( ReporterConfig const& _config )
        ^
catch.hpp:5726:9: style: Struct 'StreamingReporterBase < ConsoleReporter >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        StreamingReporterBase( ReporterConfig const& _config )
        ^
catch.hpp:5726:9: style: Struct 'StreamingReporterBase < XmlReporter >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        StreamingReporterBase( ReporterConfig const& _config )
        ^
catch.hpp:4402:9: style: Class 'Option < AssertionResult >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Option( T const& _value )
        ^
catch.hpp:4402:9: style: Class 'Option < unsigned long >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        Option( T const& _value )
        ^
catch.hpp:8972:9: style: Class 'ResultValueBase < ParseResultType >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        ResultValueBase( Type type ) : ResultBase( type ) {}
        ^
catch.hpp:8972:9: style: Class 'ResultValueBase < ParseState >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
        ResultValueBase( Type type ) : ResultBase( type ) {}
        ^
catch.hpp:3353:13: style: Struct 'MatchNotOf < std :: exception >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}
            ^
catch.hpp:3353:13: style: Struct 'MatchNotOf < std >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}
            ^
catch.hpp:3353:13: style: Struct 'MatchNotOf < double >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}
            ^
catch.hpp:3353:13: style: Struct 'MatchNotOf < std :: string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}
            ^
catch.hpp:9136:22: style: The function 'isFlag' overrides a function in a base class but is not marked with a 'override' specifier. [missingOverride]
        virtual auto isFlag() const -> bool { return true; }
                     ^
catch.hpp:9129:22: note: Virtual function in base class
        virtual auto isFlag() const -> bool { return false; }
                     ^
catch.hpp:9136:22: note: Function in derived class
        virtual auto isFlag() const -> bool { return true; }
                     ^
catch.hpp:11795:14: style: Condition '!uncaught_exceptions()' is always true [knownConditionTrueFalse]
        if ( !uncaught_exceptions() && !m_moved ){
             ^
catch.hpp:11858:14: style: Condition '!uncaught_exceptions()' is always true [knownConditionTrueFalse]
        if ( !uncaught_exceptions() ){
             ^
catch.hpp:15511:27: style: Condition '0x80<=value' is always true [knownConditionTrueFalse]
                    (0x80 <= value && value < 0x800   && encBytes > 2) ||
                          ^
catch.hpp:15510:28: note: Assuming that condition 'value<0x80' is not redundant
                    (value < 0x80) ||
                           ^
catch.hpp:15511:27: note: Condition '0x80<=value' is always true
                    (0x80 <= value && value < 0x800   && encBytes > 2) ||
                          ^
planilhas.cpp:31:22: style: Condition 'celula->formula[i]!='-'' is always true [knownConditionTrueFalse]
  celula->formula[i] != '-' || celula->formula[i] != '*' || celula->formula[i] != '/') {
                     ^
planilhas.cpp:30:87: note: Assuming that condition 'celula->formula[i]!='+'' is not redundant
  if (!(celula->formula[i] >= '0' && celula->formula[i] <= '9') || celula->formula[i] != '+' ||
                                                                                      ^
planilhas.cpp:31:22: note: Condition 'celula->formula[i]!='-'' is always true
  celula->formula[i] != '-' || celula->formula[i] != '*' || celula->formula[i] != '/') {
                     ^
planilhas.cpp:31:80: style: Condition 'celula->formula[i]!='/'' is always true [knownConditionTrueFalse]
  celula->formula[i] != '-' || celula->formula[i] != '*' || celula->formula[i] != '/') {
                                                                               ^
planilhas.cpp:31:51: note: Assuming that condition 'celula->formula[i]!='*'' is not redundant
  celula->formula[i] != '-' || celula->formula[i] != '*' || celula->formula[i] != '/') {
                                                  ^
planilhas.cpp:31:80: note: Condition 'celula->formula[i]!='/'' is always true
  celula->formula[i] != '-' || celula->formula[i] != '*' || celula->formula[i] != '/') {
                                                                               ^
catch.hpp:8542:9: style: Local variable 'width' shadows outer function [shadowFunction]
   auto width = m_column.m_width - indent();
        ^
catch.hpp:8634:7: note: Shadowed declaration
 auto width(size_t newWidth) -> Column& {
      ^
catch.hpp:8542:9: note: Shadow variable
   auto width = m_column.m_width - indent();
        ^
calculadora.hpp:80:22: style: Local variable 'op' shadows outer argument [shadowArgument]
                char op = operadores.top();
                     ^
calculadora.hpp:75:24: note: Shadowed declaration
    void operador(char op){
                       ^
calculadora.hpp:80:22: note: Shadow variable
                char op = operadores.top();
                     ^
catch.hpp:15697:53: style: Parameter 'result' can be declared with const [constParameter]
    void prepareExpandedExpression(AssertionResult& result) {
                                                    ^
catch.hpp:1482:27: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
                intValues.push_back( static_cast<int>( enumValue ) );
                          ^
catch.hpp:3608:45: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
                    if (el == m_comparator) {
                                            ^
catch.hpp:3634:47: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
                        if (el == comparator) {
                                              ^
catch.hpp:8700:17: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
    m_iterators.push_back(col.end());
                ^
catch.hpp:8716:17: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
    m_iterators.push_back(col.begin());
                ^
catch.hpp:9426:0: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
                if( normaliseOpt( name ) == normalisedToken )
^
catch.hpp:9577:26: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
                optWidth = (std::max)(optWidth, cols.left.size() + 2);
                         ^
catch.hpp:10590:24: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
                parsed.push_back(trim(extractInstanceName(enumValue)));
                       ^
catch.hpp:10599:0: style: Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]
                if( valueToName.first == value )
^
catch.hpp:10836:32: style: Consider using std::find_if algorithm instead of a raw loop. [useStlAlgorithm]
            if (sig == def.id) {
                               ^
catch.hpp:11249:18: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            size += spelling.size() + 2;
                 ^
catch.hpp:11301:24: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );
                       ^
catch.hpp:12619:50: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
                                 filters.end() ) {
                                                 ^
catch.hpp:14079:23: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            full_size += tag.size();
                      ^
catch.hpp:14171:35: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
                    indexed_tests.emplace_back(h(testCase), &testCase);
                                  ^
catch.hpp:14186:28: style: Consider using std::transform algorithm instead of a raw loop. [useStlAlgorithm]
                    sorted.emplace_back(*hashed.second);
                           ^
catch.hpp:14220:25: style: Consider using std::copy_if algorithm instead of a raw loop. [useStlAlgorithm]
                filtered.push_back(testCase);
                        ^
catch.hpp:14599:18: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            name += p->name();
                 ^
catch.hpp:15059:11: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
        s += (c <= 0xff) ? static_cast<char>(c) : '?';
          ^
planilhas.cpp:74:21: error: Uninitialized struct member: nova_celula.valor [uninitStructMember]
  celulas[celula] = nova_celula;
                    ^
catch.hpp:10214:20: style: Unused variable: guard [unusedVariable]
        ErrnoGuard guard;
                   ^
catch.hpp:15712:20: style: Unused variable: guard [unusedVariable]
        ErrnoGuard guard;
                   ^
catch.hpp:17452:30: error: syntax error: =[...]; [syntaxError]
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
                             ^
catch.hpp:4869:20: error: syntax error: =[...]; [syntaxError]
            id obj = [[m_cls alloc] init];
                   ^
